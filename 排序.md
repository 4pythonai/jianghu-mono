4个用户在每个洞,都有自己的成绩(score),同时有自己的得分(Indicator),
这4个用户被分在2组(红组,蓝组),同时我们有 初始顺序 bootStrapOrder(即起初初始化的1,2,3,4名),
现在,我在每个洞都要强制分出1,2,3,4名.


以本洞"成绩"(score)排序,冲突解决:
   A.1 回溯上洞成绩,直至"初始顺序". BY_SCORE_REVERSE
   A.2 按照本洞输赢排序,赢者排前,输者排后.如果本洞输赢相同,则有以下两种处理方式:
       A.2.1 回溯上洞输赢,直至起始洞的出发排序.
       A.2.2 回溯上洞成绩,直至起始洞的出发排序.



以本洞"得分"(Indicator)排序,冲突解决:
   B.1 回溯上洞得分,直至"初始顺序" BY_INDICATOR_REVERSE
   B.2 按照本洞输赢排序,赢者排前,输者排后.如果本洞输赢相同,则有以下两种处理方式:
       B.2.1 回溯上洞输赢,直至起始洞的出发排序.
       B.2.2 回溯上洞得分,直至起始洞的出发排序.


排序决策根节点
├── A. 按本洞"成绩"(score)排序
│   ├── A.1 回溯上洞成绩,直至"初始顺序" (BY_SCORE_REVERSE)
│   └── A.2 按本洞输赢排序
│       ├── A.2.1 回溯上洞输赢,直至起始洞出发排序
│       └── A.2.2 回溯上洞成绩,直至起始洞出发排序
│
└── B. 按本洞"得分"(Indicator)排序  
    ├── B.1 回溯上洞得分,直至"初始顺序" (BY_INDICATOR_REVERSE)
    └── B.2 按本洞输赢排序
        ├── B.2.1 回溯上洞输赢,直至起始洞出发排序
        └── B.2.2 回溯上洞得分,直至起始洞出发排序


// A类排序（按成绩）
"score.reverse"                    // A.1: 按成绩排序，冲突时回溯成绩
"score.win_loss.reverse_win"       // A.2.1: 按成绩排序，按输赢，回溯输赢
"score.win_loss.reverse_score"     // A.2.2: 按成绩排序，按输赢，回溯成绩

// B类排序（按得分）
"indicator.reverse"                // B.1: 按得分排序，冲突时回溯得分
"indicator.win_loss.reverse_win"   // B.2.1: 按得分排序，按输赢，回溯输赢
"indicator.win_loss.reverse_indicator" // B.2.2: 按得分排序，按输赢，回溯得分



我们已经确定了排序方式"4_乱拉",你只要完成这个模式下面的算法, 
// A类排序（按成绩）
"score.reverse"                    // A.1: 按成绩排序，冲突时回溯成绩
"score.win_loss.reverse_win"       // A.2.1: 按成绩排序，按输赢，回溯输赢
"score.win_loss.reverse_score"     // A.2.2: 按成绩排序，按输赢，回溯成绩

// B类排序（按得分）
"indicator.reverse"                // B.1: 按得分排序，冲突时回溯得分
"indicator.win_loss.reverse_win"   // B.2.1: 按得分排序，按输赢，回溯输赢
"indicator.win_loss.reverse_indicator" // B.2.2: 按得分排序，按输赢，回溯得分
上面是6中排名并列的解决方法.

通过 context 里面的 ranking4TieResolveConfig 这个配置得到6个里面的1种.

用户的score/indicator 都在 hole 里面.

bootStrapOrder 也是在 context里面可以得到. 

hole里面有 winner ,failer 属性,如 :
   $hole['winner'] = 'red';
   $hole['failer'] = 'blue'; 或

  $hole['winner'] = null;
  $hole['failer'] = null;