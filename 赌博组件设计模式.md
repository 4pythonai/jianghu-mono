# 赌博组件设计模式

## 概述

本文档基于 `E8421Meat` 组件的实现方式，定义了赌博配置组件的标准设计模式。该模式确保组件在不同使用场景下的一致性和可维护性。

## 核心原则

### 1. 多模式支持
每个配置组件必须支持三种使用模式：
- **SysConfig**: 系统规则配置（新增规则）
- **UserEdit**: 用户规则编辑（编辑现有规则）
- **UserConfig**: 用户配置（其他场景，从store读取）

### 2. 数据源分离
- **组件内部状态**: 用于 SysConfig 和 UserEdit 模式
- **Store 数据**: 用于 UserConfig 模式
- **外部配置数据**: 通过 `initConfigData()` 方法注入

### 3. 显示值计算策略
根据模式选择不同的数据源计算显示值，确保界面显示与实际数据状态一致。

## 组件结构

### 1. Properties 定义

```javascript
Component({
  properties: {
    // 可选：显式定义mode属性
    mode: {
      type: String,
      value: 'UserConfig' // 默认模式
    }
  }
})
```

### 2. Data 结构

```javascript
data: {
  // 组件内部状态
  visible: false,
  displayValue: '请配置规则',
  isDisabled: false,

  // 配置相关数据
  configOption: 0,
  configValue: 1,
  selectedOption: 0,

  // 选择器范围
  optionRange: [1, 2, 3, 4, 5],
  valueRange: Array.from({ length: 20 }, (_, i) => i + 1),
}
```

### 3. 生命周期管理

```javascript
lifetimes: {
  attached() {
    console.log('🎯 [ComponentName] 组件加载，模式:', this.properties.mode);

    if (this.properties.mode === 'SysConfig') {
      // SysConfig模式：使用独立的配置数据，不依赖Store
      this.initializeWithDefaults();
    } else if (this.properties.mode === 'UserEdit') {
      // UserEdit模式：等待外部数据初始化，不自动从Store加载
      this.initializeWithDefaults();
    }

    // 计算显示值
    this.updateDisplayValue();
    // 检查禁用状态
    this.checkDisabledState();
  },

  detached() {
    // 清理reaction
    if (this._storeReaction) {
      this._storeReaction();
    }
  }
}
```

### 4. 核心方法

#### 4.1 初始化方法

```javascript
// 使用默认值初始化
initializeWithDefaults() {
  this.setData({
    configOption: this.data.configOption || 0,
    configValue: this.data.configValue || 1,
    selectedOption: this.data.selectedOption || 0
  });
}

// 从Store初始化（仅用于UserConfig模式）
initializeFromStore() {
  const store = G4PStore;
  // 从store读取数据并设置到组件状态
  this.setData({
    configOption: store.configOption,
    configValue: store.configValue
  });
}
```

#### 4.2 显示值计算

```javascript
updateDisplayValue() {
  if (this.properties.mode === 'SysConfig' || this.properties.mode === 'UserEdit' || this.properties.mode === undefined) {
    // 使用组件内部状态
    displayValue = this.getDisplayValueFromComponentData();
  } else {
    // 使用Store数据
    displayValue = this.getDisplayValueFromStore();
  }

  this.setData({ displayValue });
}

// 从组件data获取显示值
getDisplayValueFromComponentData() {
  const { configOption, configValue, selectedOption } = this.data;
  let displayValue = '';

  // 根据组件状态计算显示值
  switch (configOption) {
    case 0:
      displayValue = `选项${configValue}`;
      break;
    case 1:
      displayValue = '选项1';
      break;
    default:
      displayValue = '请配置规则';
  }

  // 添加额外信息
  if (selectedOption === 1) {
    displayValue += '/已选择';
  }

  return displayValue;
}

// 从store获取显示值
getDisplayValueFromStore() {
  const store = G4PStore;
  // 使用工具类格式化显示值
  return ruleFormatter.formatRule(store.configOption, store.configValue);
}
```

#### 4.3 数据转换方法

```javascript
// 将组件状态转换为配置数据
convertComponentToConfig(componentState) {
  const { configOption, configValue, selectedOption } = componentState;
  
  let configData = null;
  switch (configOption) {
    case 0:
      configData = `OPTION_${configValue}`;
      break;
    case 1:
      configData = 'OPTION_1';
      break;
  }

  return {
    configData,
    maxValue: selectedOption === 0 ? 10000000 : configValue
  };
}

// 将配置数据转换为组件状态
convertConfigToComponent(configData) {
  const { configData: config, maxValue } = configData;
  const state = {};

  if (config?.startsWith('OPTION_')) {
    state.configOption = 0;
    const value = Number.parseInt(config.replace('OPTION_', ''));
    state.configValue = Number.isNaN(value) ? 1 : value;
  } else if (config === 'OPTION_1') {
    state.configOption = 1;
  } else {
    state.configOption = 0;
    state.configValue = 1;
  }

  state.selectedOption = maxValue === 10000000 ? 0 : 1;

  return state;
}
```

#### 4.4 公共接口方法

```javascript
// 获取配置数据（供外部调用）
getConfigData() {
  const componentState = {
    configOption: this.data.configOption,
    configValue: this.data.configValue,
    selectedOption: this.data.selectedOption
  };

  return this.convertComponentToConfig(componentState);
}

// 初始化配置数据（供UserRuleEdit页面调用）
initConfigData(configData) {
  if (!configData) return;

  const componentState = this.convertConfigToComponent(configData);
  this.setData(componentState);
  this.updateDisplayValue();
}
```

### 5. 事件处理方法

```javascript
// 选项改变事件
onOptionChange(e) {
  const index = Number.parseInt(e.currentTarget.dataset.index);
  this.setData({ configOption: index });
  this.updateDisplayValue();
}

// 数值改变事件
onValueChange(e) {
  const selectedIndex = e.detail.value;
  const selectedValue = this.data.valueRange[selectedIndex];
  this.setData({ configValue: selectedValue });
  this.updateDisplayValue();
}

// UI控制方法
onShowConfig() {
  this.setData({ visible: true });
}

onCancel() {
  this.setData({ visible: false });
}

onConfirm() {
  this.updateDisplayValue();
  this.setData({ visible: false });
  this.triggerEvent('confirm', {
    value: this.getConfigData()
  });
}

// 空方法，用于阻止事件冒泡
noop() {
  return;
}
```

## WXML 模板结构

### 1. 基本结构

```xml
<!-- 规则配置组件 -->
<view class="rule-section {{isDisabled ? 'disabled' : ''}}" wx:if="{{!visible}}">
  <view class="form-label">规则名称</view>
  <view class="form-select" bindtap="onShowConfig">
    <view class="form-input-simulator">{{displayValue}}</view>
    <view class="select-arrow">
      <text class="arrow-circle">▼</text>
    </view>
  </view>
</view>

<!-- 配置弹窗 -->
<view wx:if="{{visible}}" class="modal-mask" bindtap="onCancel">
  <view class="modal-content" catchtap="noop">
    <view class="modal-title">规则配置</view>
    <view class="modal-list">
      <!-- 配置选项 -->
    </view>
    <view class="modal-actions">
      <button class="modal-btn cancel" bindtap="onCancel">取消</button>
      <button class="modal-btn confirm" bindtap="onConfirm">确定</button>
    </view>
  </view>
</view>
```

### 2. 配置选项模板

```xml
<!-- 单选选项 -->
<view class="modal-item" bindtap="onOptionChange" data-index="0">
  <view class="radio-outer {{configOption === 0 ? 'checked' : ''}}">
    <view class="radio-inner" wx:if="{{configOption === 0}}"></view>
  </view>
  <view class="option-content">
    <text>选项</text>
    <picker
      wx:if="{{configOption === 0}}"
      class="value-picker"
      range="{{valueRange}}"
      value="{{configValue - 1}}"
      bindchange="onValueChange"
    >
      <view class="picker-value">{{configValue}}</view>
    </picker>
    <text wx:if="{{configOption !== 0}}">{{configValue}}</text>
  </view>
</view>
```

## 使用场景

### 1. SysConfig 模式（系统规则配置）

```xml
<!-- SysEdit.wxml -->
<ComponentName mode="SysConfig" />
```

- 使用组件内部默认值
- 用户配置新规则
- 保存时创建新规则

### 2. UserEdit 模式（用户规则编辑）

```xml
<!-- UserRuleEdit.wxml -->
<ComponentName mode="UserEdit" />
```

```javascript
// UserRuleEdit.js
const componentInstance = this.selectComponent('#ComponentName');
componentInstance.initConfigData(ruleData);
```

- 等待外部数据初始化
- 用户编辑现有规则
- 保存时更新现有规则

### 3. UserConfig 模式（用户配置）

```xml
<!-- 其他页面 -->
<ComponentName />
```

- 从store读取数据
- 用于其他场景
- 自动同步到store

## 最佳实践

### 1. 命名规范
- 组件名：`GameTypeConfigItem`（如 `E8421Meat`）
- 方法名：`onEventName`（如 `onOptionChange`）
- 数据名：`camelCase`（如 `configOption`）

### 2. 错误处理
```javascript
// 数据解析时添加错误处理
if (typeof configData === 'string') {
  try {
    configData = JSON.parse(configData);
  } catch (error) {
    console.error('解析配置数据失败:', error);
    configData = {};
  }
}
```

### 3. 日志记录
```javascript
console.log('🎯 [ComponentName] 组件加载，模式:', this.properties.mode);
console.log('🎯 [ComponentName] 配置数据已更新:', configData);
```

### 4. 性能优化
- 使用 `wx:if` 而不是 `wx:show` 控制弹窗显示
- 合理使用 `catchtap` 阻止事件冒泡
- 及时清理 reaction 避免内存泄漏

## 重构指南

### 1. 现有组件改造步骤

1. **添加模式支持**
   - 在 `attached()` 中添加模式判断
   - 实现 `initializeWithDefaults()` 方法

2. **修改显示值计算**
   - 实现 `getDisplayValueFromComponentData()` 方法
   - 修改 `updateDisplayValue()` 逻辑

3. **添加数据转换方法**
   - 实现 `convertComponentToConfig()` 方法
   - 实现 `convertConfigToComponent()` 方法

4. **添加公共接口**
   - 实现 `getConfigData()` 方法
   - 实现 `initConfigData()` 方法

### 2. 测试要点

- 三种模式下的初始化是否正确
- 显示值计算是否准确
- 数据转换是否完整
- 事件处理是否正常
- 弹窗交互是否流畅

## 总结

该设计模式确保了配置组件在不同使用场景下的一致性和可维护性。通过明确的数据源分离和模式化设计，使得组件既能独立工作，又能与系统其他部分良好集成。

遵循此模式的组件将具有：
- **一致性**：所有组件遵循相同的设计模式
- **可维护性**：清晰的代码结构和职责分离
- **可扩展性**：易于添加新功能和修改现有功能
- **可测试性**：明确的方法职责和数据结构
